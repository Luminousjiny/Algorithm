# ğŸ“‘ BOJ_20058_ë§ˆë²•ì‚¬ìƒì–´ì™€íŒŒì´ì–´ìŠ¤í†°(ë‹¤ì‹œ ìƒê°í•´ë³´ê¸°)     
![image](https://user-images.githubusercontent.com/72757829/112168967-1f3a4580-8c35-11eb-88a3-a83ab97942b2.png)     
![image](https://user-images.githubusercontent.com/72757829/112169199-53156b00-8c35-11eb-9550-48bc3d3d7aa4.png)     
- [ë¬¸ì œ] https://www.acmicpc.net/problem/20058
---     
> _Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException_ ì—ëŸ¬ë°œìƒ       
> ì´ ë°©ë²•ì€ L 1ë¶€í„° Lê¹Œì§€ ê³„ì† ëŒë ¤ì¤˜ì•¼í•œë‹¤...        
> ë¬¸ì œë¥¼ ì˜ ëª» ì´í•´í–ˆë‹¤... ìƒê°ì„ ë‹¤ì‹œí•˜ì        
> ì˜ˆë¥¼ë“¤ì–´ L=2ë©´, 4X4ë°•ìŠ¤ë¡œ ë‚˜ëˆ„ì–´ì„œ ê·¸ ì˜ì—­ì—ì„œë§Œ ëŒë ¤ì•¼ í•˜ê³ ,        
> 1í–‰ì€ 1ì—´, 1ì—´ì€ ë§ˆì§€ë§‰ í–‰, ë§ˆì§€ë§‰ í–‰ì€ 1ì—´, 1ì—´ì€ 1í–‰ ì´ëŸ°ì‹ìœ¼ë¡œ 90ë„ íšŒì „í•´ì•¼í•œë‹¤.       

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_20058_ë§ˆë²•ì‚¬íŒŒì´ì–´ìŠ¤í†° {
    static StringTokenizer st;
    static int N, Q, n, SUM, MAX;
    static int[] L;
    static int[][] map, nextMap;
    static int[] di = { 0, 1, -1, 0}; // ìš°, í•˜, ìƒ, ì¢Œ
    static int[] dj = { 1, 0, 0, -1};
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        Q = Integer.parseInt(st.nextToken());
        n = (int) Math.pow(2,N);
        map = new int[n][n];
        for (int i = 0; i < N; i++) { // ì–¼ìŒ ì±„ìš°ê¸°
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        L = new int[Q];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < Q; i++) { // Q ê°œì˜ L ê°’ ì…ë ¥
            L[i] = Integer.parseInt(st.nextToken());
        }

        nextMap = new int[n][n]; // ì´ë™í•  ë§µ
        for (int i = 0; i < Q; i++) {
            int nowL = L[i];
            int end = (int)Math.pow(2, N);
            int jump = (int)Math.pow(2,nowL) / 2;
            for (int j = 0; j < end; j+=jump) { // ì‹œì‘ì 
                int row = 0;
                for (int k = 0; k < end; k+=jump) {
                    // ìš° í•˜ ìš° í•˜..... í•˜ë‹¤ê°€ ì‹œì‘í–‰ì´ ë°”ë€Œë©´ ìƒ ì¢Œ ìƒ ì¢Œ .... ì´ë¥¼ ë°˜ë³µ
                    int nowDir = 0;
                    int cnt1 = 0; int cnt2 = 0;
                    if(row%2 == 0) { // ì§ìˆ˜ë©´ ìš° í•˜ ë°˜ë³µ   di dj ë¥¼ 0 1 0 1 ..
                        if(cnt1%2 == 0){
                            nowDir = 0; // ìš°
                        }else{
                            nowDir = 1; // í•˜
                        }
                        cnt1++;
                    }else{ // í™€ìˆ˜ë©´ ìƒ ì¢Œ ë°˜ë³µ  di dj ë¥¼ 2 3 2 3 ..
                        if(cnt2%2 == 0){
                            nowDir = 2; // ìƒ
                        }else{
                            nowDir = 3; // ì¢Œ
                        }
                        cnt2++;
                    }

                    Move(j, k, jump, nowDir); // ì‹œì‘ì , ì‘ì€ í•œë³€ì˜ ê¸¸ì´, ì´ë™ë°©í–¥
                    Direction();
                    copy();
                    row++;
                }
            }
        }

        MAX = Integer.MIN_VALUE;
        boolean chk = true;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if(map[i][j] != 0){ // bfs ëŒë¦¬ê¸° ... ê°œìˆ˜ë‘ í•©
                    BFS(i, j);
                    chk = false;
                }
            }
        }

        System.out.println(SUM);
        if(chk) System.out.println(0);
        else System.out.println(MAX);
    }

    private static void BFS(int si, int sj) {
        int count = 0;
        Queue<Point> qu = new LinkedList<>();
        boolean[][] visit = new boolean[n][n];
        qu.add(new Point(si, sj));
        visit[si][sj] = true;
        SUM += map[si][sj];
        while (!qu.isEmpty()){
            Point now = qu.poll();
            for (int dir = 0; dir < 4; dir++) {
                int nx = now.x + di[dir];
                int ny = now.y + dj[dir];
                if(nx<0 || nx>=n || ny<0 || ny>=n || visit[nx][ny]) continue;
                qu.add(new Point(nx, ny));
                visit[nx][ny] = true;
                SUM += map[nx][ny];
                count++;
            }
        }
        MAX = Math.max(MAX, count);
    }

    private static void copy() { // ë‹¤ì‹œ map ì— ë„£ì–´ì¤Œ
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                map[i][j] = nextMap[i][j];
            }
        }
    }

    private static void Direction() { // 4ë°©íƒìƒ‰
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int dir = 0; dir < 4; dir++) {
                    int nx = i + di[dir];
                    int ny = j + dj[dir];
                    if(nx<0 || nx>=n || ny<0 || ny>=n) continue;
                    if(nextMap[nx][ny] != 0) cnt++;
                }
                if(cnt<3) nextMap[i][j]--; // 3ì¹¸ì´ìƒ ì¸ì ‘í•˜ì§€ ì•Šìœ¼ë©´ -1
            }
        }

    }

    private static void Move(int sx, int sy, int jump, int dir) {
        if(dir == 0){ // ìš° : í–‰ì€ ê·¸ëŒ€ë¡œ ì—´ + jump
            for (int i = sx; i < sx+jump; i++) {
                for (int j = sy; j < sy+jump; j++) {
                    nextMap[i][j+jump] = map[i][j];
                }
            }
        }else if(dir == 1){ // í•˜ : í–‰+
            for (int i = sx; i < sx+jump; i++) {
                for (int j = sy; j < sy+jump; j++) {
                    nextMap[i+jump][j] = map[i][j];
                }
            }
        }else if(dir == 2){ // ìƒ
            for (int i = sx; i < sx+jump; i++) {
                for (int j = sy; j < sy+jump; j++) {
                    nextMap[i-jump][j] = map[i][j];
                }
            }
        } else{ // ì¢Œ : ì—´ -
            for (int i = sx; i < sx+jump; i++) {
                for (int j = sy; j < sy+jump; j++) {
                    nextMap[i][j-jump] = map[i][j];
                }
            }
        }
    }

    static class Point{
        int x, y;
        Point(int x, int y){
            this.x = x;
            this.y = y;
        }
    }
}
```
