# 📑 BOJ_20058_마법사상어와파이어스톰(다시 생각해보기)     
![image](https://user-images.githubusercontent.com/72757829/112168967-1f3a4580-8c35-11eb-88a3-a83ab97942b2.png)     
![image](https://user-images.githubusercontent.com/72757829/112169199-53156b00-8c35-11eb-9550-48bc3d3d7aa4.png)     
- [문제] https://www.acmicpc.net/problem/20058
---     
> _Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException_ 에러발생       
> 이 방법은 L 1부터 L까지 계속 돌려줘야한다...        
> 문제를 잘 못 이해했다... 생각을 다시하자        
> 예를들어 L=2면, 4X4박스로 나누어서 그 영역에서만 돌려야 하고,        
> 1행은 1열, 1열은 마지막 행, 마지막 행은 1열, 1열은 1행 이런식으로 90도 회전해야한다.       

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_20058_마법사파이어스톰 {
    static StringTokenizer st;
    static int N, Q, n, SUM, MAX;
    static int[] L;
    static int[][] map, nextMap;
    static int[] di = { 0, 1, -1, 0}; // 우, 하, 상, 좌
    static int[] dj = { 1, 0, 0, -1};
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        Q = Integer.parseInt(st.nextToken());
        n = (int) Math.pow(2,N);
        map = new int[n][n];
        for (int i = 0; i < N; i++) { // 얼음 채우기
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        L = new int[Q];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < Q; i++) { // Q 개의 L 값 입력
            L[i] = Integer.parseInt(st.nextToken());
        }

        nextMap = new int[n][n]; // 이동할 맵
        for (int i = 0; i < Q; i++) {
            int nowL = L[i];
            int end = (int)Math.pow(2, N);
            int jump = (int)Math.pow(2,nowL) / 2;
            for (int j = 0; j < end; j+=jump) { // 시작점
                int row = 0;
                for (int k = 0; k < end; k+=jump) {
                    // 우 하 우 하..... 하다가 시작행이 바뀌면 상 좌 상 좌 .... 이를 반복
                    int nowDir = 0;
                    int cnt1 = 0; int cnt2 = 0;
                    if(row%2 == 0) { // 짝수면 우 하 반복   di dj 를 0 1 0 1 ..
                        if(cnt1%2 == 0){
                            nowDir = 0; // 우
                        }else{
                            nowDir = 1; // 하
                        }
                        cnt1++;
                    }else{ // 홀수면 상 좌 반복  di dj 를 2 3 2 3 ..
                        if(cnt2%2 == 0){
                            nowDir = 2; // 상
                        }else{
                            nowDir = 3; // 좌
                        }
                        cnt2++;
                    }

                    Move(j, k, jump, nowDir); // 시작점, 작은 한변의 길이, 이동방향
                    Direction();
                    copy();
                    row++;
                }
            }
        }

        MAX = Integer.MIN_VALUE;
        boolean chk = true;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if(map[i][j] != 0){ // bfs 돌리기 ... 개수랑 합
                    BFS(i, j);
                    chk = false;
                }
            }
        }

        System.out.println(SUM);
        if(chk) System.out.println(0);
        else System.out.println(MAX);
    }

    private static void BFS(int si, int sj) {
        int count = 0;
        Queue<Point> qu = new LinkedList<>();
        boolean[][] visit = new boolean[n][n];
        qu.add(new Point(si, sj));
        visit[si][sj] = true;
        SUM += map[si][sj];
        while (!qu.isEmpty()){
            Point now = qu.poll();
            for (int dir = 0; dir < 4; dir++) {
                int nx = now.x + di[dir];
                int ny = now.y + dj[dir];
                if(nx<0 || nx>=n || ny<0 || ny>=n || visit[nx][ny]) continue;
                qu.add(new Point(nx, ny));
                visit[nx][ny] = true;
                SUM += map[nx][ny];
                count++;
            }
        }
        MAX = Math.max(MAX, count);
    }

    private static void copy() { // 다시 map 에 넣어줌
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                map[i][j] = nextMap[i][j];
            }
        }
    }

    private static void Direction() { // 4방탐색
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int dir = 0; dir < 4; dir++) {
                    int nx = i + di[dir];
                    int ny = j + dj[dir];
                    if(nx<0 || nx>=n || ny<0 || ny>=n) continue;
                    if(nextMap[nx][ny] != 0) cnt++;
                }
                if(cnt<3) nextMap[i][j]--; // 3칸이상 인접하지 않으면 -1
            }
        }

    }

    private static void Move(int sx, int sy, int jump, int dir) {
        if(dir == 0){ // 우 : 행은 그대로 열 + jump
            for (int i = sx; i < sx+jump; i++) {
                for (int j = sy; j < sy+jump; j++) {
                    nextMap[i][j+jump] = map[i][j];
                }
            }
        }else if(dir == 1){ // 하 : 행+
            for (int i = sx; i < sx+jump; i++) {
                for (int j = sy; j < sy+jump; j++) {
                    nextMap[i+jump][j] = map[i][j];
                }
            }
        }else if(dir == 2){ // 상
            for (int i = sx; i < sx+jump; i++) {
                for (int j = sy; j < sy+jump; j++) {
                    nextMap[i-jump][j] = map[i][j];
                }
            }
        } else{ // 좌 : 열 -
            for (int i = sx; i < sx+jump; i++) {
                for (int j = sy; j < sy+jump; j++) {
                    nextMap[i][j-jump] = map[i][j];
                }
            }
        }
    }

    static class Point{
        int x, y;
        Point(int x, int y){
            this.x = x;
            this.y = y;
        }
    }
}
```
